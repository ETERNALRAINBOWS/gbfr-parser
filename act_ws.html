<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Remote</title>
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@latest/dist/css/bootstrap.min.css"/>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.21.3/full/pyodide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@latest/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus"></script>
    <script src="https://unpkg.com/@element-plus/icons-vue"></script>
</head>
<style>
    body {
        font-family: -apple-system,
        'Nimbus Roman No9 L',
        'PingFang SC Regular',
        'Hiragino Sans GB',
        'Microsoft Yahei',
        'WenQuanYi Micro Hei',
        'ST Heiti', sans-serif
    }

    ::-webkit-scrollbar {
        width: 5px;
        height: 5px;
        background-color: #F5F5F5;
    }

    ::-webkit-scrollbar-track {
        -webkit-box-shadow: inset 0 0 6px rgb(93, 93, 93);
        border-radius: 10px;
        background-color: #F5F5F5;
    }

    ::-webkit-scrollbar-thumb {
        border-radius: 10px;
        -webkit-box-shadow: inset 0 0 6px rgba(166, 166, 166, 0.3);
        background-color: rgb(234, 234, 234);
    }

    .main-0 {
        display: table;
        position: absolute;
        height: 100%;
        width: 100%;
    }

    .main-1 {
        display: table-cell;
        vertical-align: middle;
    }

    .main-2 {
        width: 1000px;
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
    }
</style>
<body>
<div id="app" class="main-0">
    <div class="main-1">
        <div class="main-2 shadow rounded p-3">
            <div v-if="!is_socket_connected" class="p-3">
                <el-alert title="socket is not connect, check inject status" type="error" effect="dark" :closable="false"></el-alert>
            </div>

            <el-tabs
                    v-model="view_record_value"
                    type="card"
                    closable @tab-remove="remove_record"
            >
                <el-tab-pane
                        v-for="item in records" :key="item.name" :label="item.name" :name="item.name"
                >
                    <el-table :data="Object.values(item.actors)" style="width: 100%" :default-sort="{ prop: 'dps', order: 'descending' }">
                        <el-table-column prop="name" label="name"></el-table-column>
                        <el-table-column prop="damage" label="damage" sortable></el-table-column>
                        <el-table-column prop="damage_in_minute" label="damage_in_minute" sortable></el-table-column>
                        <el-table-column prop="dps" label="dps" sortable></el-table-column>
                        <el-table-column prop="dps_in_minute" label="dps_in_minute" sortable></el-table-column>
                        <el-table-column type="expand">
                            <template #default="props">
                                {{props.row.targets}}
                            </template>
                        </el-table-column>
                    </el-table>
                    </el-table>
                </el-tab-pane>
            </el-tabs>
        </div>
    </div>
</div>
</body>
<script>
    const _with_time = f => (...args) => {
        const now = new Date();
        f(`[${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}]`, ...args);
    }

    const log = _with_time(console.log);
    const err = _with_time(console.error);
    const flag_offs = (val) => Array.from(Array(val.toString(2).length).keys())
        .filter(off => val & (1 << off));

    const actor_names = {
        0x9498420d: "姬塔",
        0x26a4848a: "古兰",
        0xc3155079: "赛达",
        0x34d4fd8f: "卡塔莉娜",
        0xf8d73d33: "拉卡姆",
        0x7b5934ad: "伊欧",
        0x443d46bb: "欧根",
        0xa9d6569e: "萝赛塔",
        0x2b4aa114: "夏洛特",
        0xbcc238de: "冈达葛萨",
        0xfba6615d: "菲莉",
        0x601aa977: "娜露梅",
        0x63a7c3f0: "兰斯洛特",
        0xf96a90c2: "巴恩",
        0x28ac1108: "珀西瓦尔",
        0x94e2514e: "齐格飞",
        0x6fdd6932: "卡莉奥丝特罗",
        0xc97f3365: "尤达哈拉",
        0xd16cfbde: "巴萨拉卡",
        0x8056abcd: "伊德",
        0xf5755c0e: "伊德（龙人化）",
    }
    var socket = null;

    function numberToHexStringWithZFill(number, minLength) {
        let hexString = number.toString(16);
        while (hexString.length < minLength) {
            hexString = '0' + hexString;
        }
        return hexString;
    }

    const App = Vue.createApp({
        setup() {
            const is_socket_connected = Vue.ref(false);
            const drawer = Vue.ref(false);
            const records = Vue.ref([]);
            const view_record_value = Vue.ref("");
            var want_new = false;
            var update_period = 0;
            const remove_record = (name) => {
                console.log('remove_record', name);
                records.value = records.value.filter((item) => item.name !== name);
                if (view_record_value.value === name) {
                    if (records.value.length === 0) new_record();
                    view_record_value.value = records.value[records.value.length - 1].name;
                }
            }
            const fmt_time = (ms) => {
                if (ms < 1000) return ms + "ms";
                const sec = Math.floor(ms / 1000);
                if (sec < 60) return sec + "s";
                const min = Math.floor(sec / 60);
                return min + "m";
            }
            const new_record = () => {
                const now = new Date();
                records.value.push({
                    name: `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`,
                    time: now.getTime(),
                    last_record_at: new Date().getTime(),
                    actors: {},
                    events_in_minute: [],
                });
                view_record_value.value = records.value[records.value.length - 1].name;
                want_new = false;
            }

            const get_latest_record = () => {
                if (records.value.length === 0) new_record();
                return records.value[records.value.length - 1];
            }
            const get_actor = (source_idx, source_id) => {
                const current_record = get_latest_record();
                if (!current_record.actors[source_idx]) current_record.actors[source_idx] = {
                    name: `${actor_names[source_id] || numberToHexStringWithZFill(source_id, 8)}[${source_idx}]`,
                    damage: 0,
                    damage_in_minute: 0,
                    dps: 0,
                    dps_in_minute: 0,
                    targets: {},
                };
                return current_record.actors[source_idx];
            }
            const on_damage = (evt) => {
                const {source, target, damage, flags} = evt;
                const [source_type, source_idx, source_id, ..._] = source;
                const [target_type, target_idx, target_id, ...__] = target;
                // if (target_type === "BehaviorAppBase") return;
                // if (source_type !== "BehaviorPlayerBase") return;
                const now = new Date().getTime()
                const current_record = get_latest_record();
                current_record.last_record_at = now;
                if (!(source_id in actor_names)) return;
                const actor = get_actor(source_idx, source_id);
                current_record.events_in_minute.push({
                    time: now,
                    type: "damage",
                    data: evt
                });
                actor.damage += damage;
                actor.damage_in_minute += damage;
                const target_key = `${numberToHexStringWithZFill(target_id, 8)}[${target_idx}]`;
                if (!(target_key in actor.targets)) actor.targets[target_key] = 0;
                actor.targets[target_key] += damage;
            }

            const process_old_records = () => {
                const current_record = get_latest_record();
                const min_time = new Date().getTime() - 60000;
                while (current_record.events_in_minute.length > 0) {
                    const first_evt = current_record.events_in_minute[0];
                    if (first_evt.time > min_time) break;
                    current_record.events_in_minute.shift();
                    switch (first_evt.type) {
                        case "damage":
                            const {source, target, damage, flags} = first_evt.data;
                            const [source_type, source_idx, source_id, ..._] = source;
                            const actor = get_actor(source_idx, source_id);
                            actor.damage_in_minute -= damage;
                            break;
                    }
                }
            }

            const calc_damages = () => {
                const current_record = get_latest_record();
                const full_time = (current_record.last_record_at - current_record.time) / 1000;
                const full_time_in_minute = Math.min(60000, new Date().getTime() - current_record.time) / 1000;
                for (const actor of Object.values(current_record.actors)) {
                    actor.dps = Math.floor(actor.damage / full_time);
                    actor.dps_in_minute = Math.floor(actor.damage_in_minute / full_time_in_minute);
                }
            }


            const update = () => {
                process_old_records();
                calc_damages();
                if (update_period > 0) setTimeout(update, update_period);
            }

            const create_socket = () => {
                const socket_ = new WebSocket("ws://localhost:24399");
                socket_.addEventListener("message", evt_ => {
                    log(evt_.data);
                    const evt = JSON.parse(evt_.data);
                    switch (evt.type) {
                        case "enter_area":
                            want_new = true;
                            break;
                        case "damage":
                            if (want_new) new_record();
                            on_damage(evt.data);
                            break;
                    }
                });
                socket_.addEventListener("open", () => {
                    is_socket_connected.value = true;
                    socket = socket_;
                });
                socket_.addEventListener("close", () => {
                    is_socket_connected.value = false;
                    socket = null;
                });
                socket_.addEventListener("error", evt => {
                    console.error("Ws Error", evt);
                    is_socket_connected.value = false;
                    socket = null;
                    if (update_period > 0)
                        setTimeout(create_socket, update_period);
                });
            }

            Vue.onMounted(() => {
                update_period = 1000;
                create_socket();
                update();
            });

            Vue.onUnmounted(() => {
                update_period = -1;
                if (socket) socket.close();
            });

            return {
                view_record_value,
                drawer,
                is_socket_connected,
                records,
                fmt_time,
                remove_record,
            }
        }
    })
    App.use(ElementPlus);
    for (const [key, component] of Object.entries(ElementPlusIconsVue)) App.component(key, component);
    App.mount('#app');

</script>
</html>
